# Class定義
snippet class
    class ${1:`Snippet_RubyClassNameFromFilename()`}${2}
    	${3}
    end

snippet classe
    class ${1:ErrorClassName} < ${2:StandardError}; end${3}

snippet sinc
    class << self; self end


# Module定義
snippet mod
    module ${1:`Snippet_RubyClassNameFromFilename()`}
    	${2}
    end

snippet module
    module ${1:`Snippet_RubyClassNameFromFilename()`}
    	module ClassMethods
    		${2}
    	end
    
    	module InstanceMethods
    
    	end
    
    	def self.included(receiver)
    		receiver.extend         ClassMethods
    		receiver.send :include, InstanceMethods
    	end
    end


# Method定義
snippet def
    def ${1:name}
    	${2}
    end

snippet defi
    def initialize${1}
    	${2}
    end

snippet defmm
    def method_missing(meth, *args, &blk)
    	${1}
    end

snippet defs
    def self.${1:class_method_name}
    	${2}
    end

snippet am
    alias_method :${1:new_name}, :${2:old_name}


# Attribute定義
snippet attrr
    attr_reader :${1:attr_names}

snippet attrrw
    attr_accessor :${1:attr_names}
   
snippet cattrrw
    cattr_accessor :${1:attr_names}

snippet attrw
    attr_writer :${1:attr_names}


# 制御構文
snippet if
    if ${1:condition}
    	${2}
    end

snippet elsif
    elsif ${1:condition}
    	${2}

snippet ife
    if ${1:condition}
    	${2}
    else
    end

snippet case
    case ${1}
    when ${2}
    else
    	${3}
    end

snippet casemini
    case ${1}
    when ${2} then ${3}
    end

snippet unless
    unless ${1:condition}
    	${2}
    end

snippet while
    while ${1:condition}
    	${2}
    end


# Block
snippet do
    do
    	${1}
    end

snippet dop
    do |${1:param}|
    	${2}
    end


# Enumerable
snippet each
prev_word '.'
    each { |${1:element}| ${2:process} }

snippet eachdo
prev_word '.'
    each do |${1:element}|
    	${2:process}
    end

snippet coll
prev_word '.'
    collect { |${1:element}| ${2:process} }
    
snippet colldo
prev_word '.'
    each do |${1:element}|
    	${2:body}
    end

snippet colls
prev_word '.'
    collect(&:${1:Method Name})

snippet map
prev_word '.'
    collect(&:${1:Method Name})

snippet sel
prev_word '.'
    select { |${1:element}| ${2:Include condition...} }

snippet selo
prev_word '.'
    select do |${1:element}|
    	${2:Include condition...}
    end

snippet det
prev_word '.'
    detect { |${1:element}| ${2:Not include condition...} }

snippet detdo
prev_word '.'
    detect do |${1:element}|
    	${2:Not include condition...}
    end
    
snippet rej
prev_word '.'
    reject { |${1:element}| ${2:Not include condition...} }

snippet rejdo
prev_word '.'
    reject do |${1:element}|
    	${2:Not include condition...}
    end
    
snippet inj
prev_word '.'
    inject(${1:init}) { |${2:total}, ${3:next}| ${4:body} }

snippet injdo
prev_word '.'
    inject(${1:init}) do |${2:total}, ${3:next}|
    	${4:body}
    end

snippet sort
    sort { |${1:x},${2:y}| ${3:body} }

snippet sorto
    sort do |${1:x},${2:y}|
    	${3:body}
    end


# File
snippet glob
    Dir.glob(${1:glob}) do |path|
      ${2}
    end

snippet openw
    open(${1:path}, 'w')

snippet fileeach
    File.foreach(${1:"<+path}"+>) { |${2:line}| ${3} }

snippet fileputs
    open(${1:path}, 'w') { |io| io.puts(${2}) }

snippet fileread
    open(${1:path}) do |f|
      f.each do |line|
        ${2}
      end
    end

snippet pathhere
    File.join(File.dirname(__FILE__), ${1:path here})


# CSV
snippet csvread
    require 'csv'

    CSV.foreach(${1:path}) do |row|
      ${2}
    end

snippet csvwrite
    require 'csv'
    
    CSV.open(${1:path}, 'w') do |writer|
      ${2}
    end


# Net::HTTP
snippet httpget
    require 'net/http'
    
    res = Net::HTTP.get URI.parse('${1:url}')

snippet httppost
    require 'net/http'
    
    res = Net::HTTP.post_form URI.parse('${1:url}')${2:, params}


# Net::FTP
snippet ftp
    require 'net/ftp'


# Net::Pop
snippet pop3
    require 'net/pop3'


# TestUnit
#snippet tc
#    require "test/unit"
#    
#    require "${1:library_file_name}"
#    
#    class Test${2:`Snippet_RubyClassNameFromFilename()`} < Test::Unit::TestCase
#    	def test_${3:case_name}
#    		${4}
#    	end
#    end
#
#snippet anr
#    assert_nothing_raised(${1:Exception}) { ${2} }
#
#snippet as
#    assert ${1:test}, "${2:failure_message}"
#
#snippet ase
#    assert_equal ${1:expected}, ${2:actual}
#
#snippet asid
#    assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:delta_float}
#
#snippet asio
#    assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}
#
#snippet asko
#    assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}
#
#snippet asm
#    assert_match /${1:expected_pattern}/, ${2:actual_string}
#
#snippet asn
#    assert_nil ${1:instance}
#
#snippet asne
#    assert_not_equal ${1:unexpected}, ${2:actual}
#
#snippet asnm
#    assert_no_match /${1:unexpected_pattern}/, ${2:actual_string}
#
#snippet asnn
#    assert_not_nil ${1:instance}
#
#snippet asns
#    assert_not_same ${1:unexpected}, ${2:actual}
#
#snippet asnt
#    assert_nothing_thrown { ${1} }
#
#snippet aso
#    assert_operator ${1:left}, :${2:operator}, ${3:right}
#
#snippet asr
#    assert_raise(${1:Exception}) { ${2} }
#
#snippet asrt
#    assert_respond_to ${1:object}, :${2:method}
#
#snippet ass
#    assert_send [${1:object}, :${2:message}, ${3:args}]
#
#snippet ast
#    assert_throws(:${1:expected}) { ${2} }
#
#snippet art
#    assert_redirected_to ${1::action => "${2:index}"}
#
#snippet artnp
#    assert_redirected_to <+<+parent+>_<+child+>_path(<+@<+parent+>+>, <+@<+child+>+>)+>
#
#snippet artnpp
#    assert_redirected_to <+<+parent+>_<+child+>_path(<+@<+parent+>+>)+>
#
#snippet artp
#    assert_redirected_to <+<+model+>_path(<+@<+model+>+>)+>
#
#snippet artpp
#    assert_redirected_to <+<+model+>s_path+>
#
#snippet asd
#    assert_difference "${1:Model}.${2:count}", $1 do
#    	${3}
#    end
#
#snippet asnd
#    assert_no_difference "${1:Model}.${2:count}" do
#    	${3}
#    end
#
#snippet asre
#    assert_response :${1:success}, @response.body${2}
#
#snippet asrj
#    assert_rjs :<+replace+>, <+"<+dom id+>"+>
#
#snippet ass
#    assert_select '<+path+>'<+, :<+text+> => <+'<+inner_html+>'+>+> <+do<++>+>
#
#snippet bm
#    TESTS = ${1:10_000}
#    Benchmark.bmbm do |results|
#    	${2}
#    end
#
#snippet deft
#    def test_${1:case_name}
#    	${2}
#    end
#
#snippet ip
#    ip_addr = request.env['REMOTE_ADDR']
#
#snippet rep
#    results.report("${1:name}:") { TESTS.times { ${2} } }


# Marshal
snippet Md
    File.open(${1:dump_path}, "wb") { |${2:file}| Marshal.dump(${3:obj}, ${4:$2}) }

snippet Ml
    File.open(${1:dump_path}, "rb") { |${2:file}| Marshal.load(${3:$2}) }


# PStore
snippet Pn
    PStore.new(${1})


# Rake
snippet task
    desc "${1:Task description}"
    task :${2:task_name}${3: => [:dependent, :tasks]} do
    	${4}
    end


# YAML
snippet Yd
    File.open(${1:path_to_yml}, "w") { |${2:file}| YAML.dump(${3:obj}, ${4:$2}) }

snippet Yl
    File.open(${1:path_to_yml}) { |${2:file}| YAML.load(${3:$2}) }


# Factory
snippet fac
    Factory(:<+factory_name+><+, <++>+>)<++>

snippet facb
    Factory.build(:<+factory_name+><+, <++>+>)<++>

snippet facd
    Factory.define(:${1:model}) do |${2:m}|
    	${3}
    end
    ${4}

snippet facn
    Factory.next(:${1:sequence-name})${2}

snippet facs
    Factory.sequence :${1:sequence-name} do |${2:m}|
    	${3}
    end
    ${4}


# ActionController::Base
snippet bf
    before_filter :${1:method}

snippet acacreate
    def create
    	@${1:model_class_name} = ${2:ModelClassName}.new(params[:$1])
    
    	respond_to do |wants|
    		if @$1.save
    			flash[:notice] = '$2 was successfully created.'
    			wants.html { redirect_to(@$1) }
    			wants.xml  { render :xml => @$1, :status => :created, :location => @$1 }
    		else
    			wants.html { render :action => "new" }
    			wants.xml  { render :xml => @$1.errors, :status => :unprocessable_entity }
    		end
    	end
    end${3}

snippet acadestroy
    def destroy
    	@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
    	@$1.destroy
    
    	respond_to do |wants|
    		wants.html { redirect_to($1s_url) }
    		wants.xml  { head :ok }
    	end
    end${3}

snippet acaedit
    def edit
    	@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
    end

snippet acaindex
    def index
    	@${1:model_class_name} = ${2:ModelClassName}.all
    
    	respond_to do |wants|
    		wants.html # index.html.erb
    		wants.xml  { render :xml => @$1s }
    	end
    end${3}

snippet acanew
    def new
    	@${1:model_class_name} = ${2:ModelClassName}.new
    
    	respond_to do |wants|
    		wants.html # new.html.erb
    		wants.xml  { render :xml => @$1 }
    	end
    end${3}

snippet acashow
    def show
    	@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
    
    	respond_to do |wants|
    		wants.html # show.html.erb
    		wants.xml  { render :xml => @$1 }
    	end
    end${3}

snippet acaupdate
    def update
    	@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
    
    	respond_to do |wants|
    		if @$1.update_attributes(params[:$1])
    			flash[:notice] = '$2 was successfully updated.'
    			wants.html { redirect_to(@$1) }
    			wants.xml  { head :ok }
    		else
    			wants.html { render :action => "edit" }
    			wants.xml  { render :xml => @$1.errors, :status => :unprocessable_entity }
    		end
    	end
    end${3}

snippet flash
    flash[:${1:notice}] = "${2}"

snippet params
    params[:${1:key}]${2}

# ActionController::Caghing::Sweeper
snippet sweeper
    class ${1:ModelClassName}Sweeper < ActionController::Caching::Sweeper
    	observe $1
    
    	def after_save(${2:model_class_name})
    		expire_cache($2)
    	end
    
    	def after_destroy($2)
    		expire_cache($2)
    	end
    
    	def expire_cache($2)
    		expire_page
    	end
    end


# ActiveRecord::Base
snippet armodel
prev_word '^'
    class ${1:ModelClassName} < ActiveRecord::Base
      ${2}
    end

snippet belongs_to
    belongs_to :${1:association}

snippet findall
prev_word '.'
    all(:conditions => ['${1:condition}', ${2:variables}])

snippet findfirst
prev_word '.'
    first(:conditions => ['${1:condition}', ${2:variables}])

snippet habtm
    has_and_belongs_to_many :${1:object}, :join_table => "${2:table_name}", :foreign_key => "${3}_id"${4}

snippet has_many
    has_many :${1:Association}, :class_name => "${2:Class Name}", :foreign_key => "${3:foreign_key}_id", :dependent => :destroy

snippet has_manyth
    has_many :${1:Association}, :through => :${2:Join association}, :source => '${3}'

snippet has_one
    has_one :${1:Association}, :class_name => "${2:Class Name}", :foreign_key => "${3:class}_id"

snippet validates_associated
    validates_associated :${1:attribute}

snippet validates_acceptance_of
    validates_acceptance_of :${1:terms}, :accept => "${2:accept}"

snippet validates_confirmation_of
    validates_confirmation_of :${1:attribute}

snippet validates_exclusion_of
    validates_exclusion_of :${1:attribute}, :in => ${2:exclusion list}

snippet validates_format_of
    validates_format_of :${1:attribute}, :with => /${2:regex}/

snippet validates_inclusion_of
    validates_inclusion_of :${1:attribute}, :in => ${2:included list}

snippet vl
    validates_length_of :<+attribute+>, :within => <+3..20+><+, :on => :<+create+>, :message => "<+must be present+>"+>

snippet vn
    validates_numericality_of :<+attribute+><+, :on => :<+create+>, :message => "<+is not a number+>"+>

snippet vpo
    validates_presence_of :${1:attribute}

snippet vu
    validates_uniqueness_of :<+attribute+><+, :on => :<+create+>, :message => "<+must be unique+>"+>

snippet ns
    named_scope :${1:name}, :conditions => ${2:conditions}

snippet nsp
    named_scope :${1:name}, proc |${2:param}|
      ${3}
    end


# I18n
snippet i18
    I18n.t('${1:type.key}')${2}


# Rails Logger
snippet log
    RAILS_DEFAULT_LOGGER.${1:debug} ${2}

snippet logd
    logger.debug { "${1:message}" }${2}

snippet loge
    logger.error { "${1:message}" }${2}

snippet logf
    logger.fatal { "${1:message}" }${2}

snippet logi
    logger.info { "${1:message}" }${2}

snippet logw
    logger.warn { "${1:message}" }${2}

snippet mapc
    ${1:map}.${2:connect} '${3:controller/:action/:id}'

snippet mapca
    ${1:map}.catch_all "*${2:anything}", :controller => "${3:default}", :action => "${4:error}"${5}

snippet mapr
    ${1:map}.resource :${2:resource}

snippet maprs
    ${1:map}.resources :${2:resource}

snippet mapwo
    ${1:map}.with_options :${2:controller} => '${3:thing}' do |$3|
    	${4}
    end

# ActiveRecord::Migration
snippet armigration
prev_word '^'
    class ${1:MigrationClassName} < ActiveRecord::Migration
    	def self.up
    		
    	end
    
    	def self.down
    	end
    end

snippet add_column
    add_column :${1:table}, :${2:column}, :${3:type}

snippet remove_column
    remove_column :${1:table}, :${2:column}

snippet rename_column
    rename_column :${1:table}, :${2:old}, :${3:new}

snippet remove_column
    remove_column :${1:table}, :${2:column}

snippet create_table
    create_table :${1:table_name} do |t|
    	t.column :${2:name}, :${3:type}
    end

snippet tcb
    t.boolean :${1:title}
    ${2}

snippet tcbi
    t.binary :<+title+><+, :limit => <+2+>.megabytes+>
    <++>

snippet tcd
    t.decimal :<+title+><+<+, :precision => <+10+>+><+, :scale => <+2+>+>+>
    <++>

snippet tcda
    t.date :${1:title}
    ${2}

snippet tcdt
    t.datetime :${1:title}
    ${2}

snippet tcf
    t.float :${1:title}
    ${2}

snippet tch
    t.change :<+name+><+, :<+string+><+, :<+limit+> => <+80+>+>+>
    <++>

snippet tci
    t.integer :${1:title}
    ${2}

snippet tcl
    t.integer :lock_version, :null => false, :default => 0
    ${1}

snippet tcr
    t.references :<+taggable+><+, :polymorphic => <+{ :default => '<+Photo+>' }+>+>
    <++>

snippet tcs
    t.string :${1:title}
    ${2}

snippet tct
    t.text :${1:title}
    ${2}

snippet tcti
    t.time :${1:title}
    ${2}

snippet tcts
    t.timestamp :${1:title}
    ${2}

snippet tctss
    t.timestamps
    ${1}

snippet trc
    t.remove :${1:column}

snippet tre
    t.rename :<+old_column_name+>, :<+new_column_name+>
    <++>

snippet tref
    t.references :${1:model}


# Digest
snippet sha1
    Digest::SHA1.hexdigest(${1:string})

snippet wants
    wants.<+js|xml|html+> <+{ <++> }+>

snippet xdelete
    xhr :delete, :${1:destroy}, :id => ${2:1}${3}

snippet xget
    xhr :get, :<+show+><+, :id => <+1+>+><++>

snippet xpost
    xhr :post, :${1:create}, :${2:object} => { ${3} }

snippet xput
    xhr :put, :${1:update}, :id => ${2:1}, :${3:object} => { ${4} }${5}

# Rspec
snippet aft
    after(${1::each}) do
    	${2}
    end

snippet bef
    before(${1::each}) do
    	${2}
    end

snippet conn
    controller_name :${1:controller}

snippet specstart
    require File.expand_path(File.dirname(__FILE__) + '/../spec_helper')
    
    describe ${1:controller} do
    	${2}
    end

snippet desct
    describe ${1:Type} do
    	${2}
    end

snippet descs
    describe "${1:subject}" do
    	${2}
    end

snippet desctd
    describe ${1:Type}, "${2:description}" do
    	${3}
    end

snippet descc
    describe ${1:controller}, "${2:GET|POST|PUT|DELETE} ${3:/some/path}${4}" do
    	${5}
    end

snippet ex
    exactly(${1:n}).times

snippet it
    it '${1}' do
    	${2}
    end

snippet its
    it "should ${1:do something}" do${2}

snippet mat
prev_word '^'
    class ${1:ReverseTo}
    	def initialize(${2:param})
    		@$2 = $2
    	end
    
    	def matches?(actual)
    		@actual = actual
    		# Satisfy expectation here. Return false or raise an error if it's not met.
    		${3:@actual.reverse.should == @$2}
    		true
    	end
    
    	def failure_message
    		"expected #{@actual.inspect} to ${4} #{@$2.inspect}, but it didn't"
    	end
    
    	def negative_failure_message
    		"expected #{@actual.inspect} not to ${5} #{@$2.inspect}, but it did"
    	end
    end
    
    def ${6:reverse_to}(${7:expected})
    	${8}.new($7)
    end

snippet mm
    mock_model(${1:model})${2}

snippet moc
    ${1:var} = mock("${2:mock_name}"${3:, :null_object => true})
    ${4}

snippet mocw
    Spec::Runner.configure do |config|
    	config.mock_with :${1:mocha|flexmock|rr}
    end

snippet specreq
    require File.dirname(__FILE__) + '/../spec_helper'

snippet sheq
    ${1:target}.should == ${2:value}
    ${3}

snippet shb
    ${1:target}.should be(${2:result})
    ${3}

snippet shbc
    ${1:target}.should be_close(${2:result}, ${3:tolerance})
    ${4}

snippet shbio
    ${1:target}.should be_instance_of(${2:class})
    ${3}

snippet shbko
    ${1:target}.should be_a_kind_of(${2:class})
    ${3}

snippet shbr
    response.should be_redirect
    ${1}

snippet shbs
    response.should be_success
    ${1}

snippet shc
    lambda {
    	${1}
    }.should change(${2:target}, :${3:method}).from(${4:old_value}).to(${5:new_value}).by(${6:change})

snippet shdm
    ${1:target}.should match(/${2:regexp}/)
    ${3}

snippet she
    ${1:target}.should eql(${2:value})
    ${3}

snippet sheq
    ${1:target}.should equal(${2:value})
    ${3}

snippet shh
    ${1:target}.should have(${2:num}).${3:things}
    ${4}

snippet shhal
    ${1:target}.should have_at_least(${2:num}).${3:things}
    ${4}

snippet shham
    ${1:target}.should have_at_most(${2:num}).${3:things}
    ${4}

snippet shhr
    ${1:target}.should have(${2:n}).records
    ${3}

snippet shneq
    ${1:target}.should_not == ${2:value}
    ${3}

snippet shnb
    ${1:target}.should_not be(${2:result})
    ${3}

snippet shnbc
    ${1:target}.should_not be_close(${2:result}, ${3:tolerance})
    ${4}

snippet shnbio
    ${1:target}.should_not be_instance_of(${2:klass})
    ${3}

snippet shnbko
    ${1:target}.should_not be_a_kind_of(${2:klass})
    ${3}

snippet shnc
    lambda do
    	${1}
    end.should_not change(${2:target}, :${3:method})

snippet shne
    ${1:target}.should_not eql(${2:value})
    ${3}

snippet shneq
    	${1:target}.should_not equal(${2:value})
    	${3}

snippet shnm
    ${1:target}.should_not match(/${2:regexp}/)
    ${3}

snippet shnp
    ${1:target}.should_not be_${2:predicate}

snippet shnr
    ${1:mock}.should_not_receive(:${2:message})${3}
    ${4}

snippet shnre
    ${1:target}.should_not raise_error(${2:error})
    ${3}

snippet shnredt
    response.should_not redirect_to(${1:url})
    ${2}

snippet shnrt
    ${1:target}.should_not respond_to(:${2:sym})
    ${3}

snippet shns
    ${1:target}.should_not satisfy { |${2:obj}| ${3} }
    ${4}

snippet shnt
    lambda { ${1} }.should_not throw_symbol(:${2:symbol})
    ${3}

snippet shp
    ${1:target}.should be_${2:predicate}

snippet shr
    ${1:mock}.should_receive(:${2:message})${3}
    ${4}

snippet shre
    ${1:target}.should raise_error(${2:error})
    ${3}

snippet shredt
    response.should redirect_to(${1:url})
    ${2}

snippet shrt
    ${1:target}.should respond_to(:${2:sym})
    ${3}

snippet shs
    ${1:target}.should satisfy { |${2:obj}| ${3} }
    ${4}

snippet sht
    ${1:target}.should throw_symble(:${2:symbol})
    ${3}

snippet shtemp
    response.should render_template(:${1:template})
    ${2}
