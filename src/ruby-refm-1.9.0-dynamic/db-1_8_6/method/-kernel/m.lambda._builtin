visibility=public
kind=defined
names=lambda,proc

--- proc { ... } -> Proc
--- lambda { ... } -> Proc
--- proc -> Proc
--- lambda -> Proc

与えられたブロックから手続きオブジェクト ([[c:Proc]] のインスタンス)
を生成して返します。[[m:Proc.new]] に近い働きをします。

ブロックが指定されなければ、呼び出し元のメソッドで指定されたブロック
を手続きオブジェクトとして返します。呼び出し元のメソッドがブロックなし
で呼ばれると [[c:ArgumentError]] 例外が発生します。

ただし、ブロックを指定しない呼び出しは推奨されていません。呼び出し元のメソッドで指定されたブロック
を得たい場合は明示的に & 引数でうけるべきです。

@raise ArgumentError スタック上にブロックがないのにブロックを省略した呼び出しを行ったときに発生します。

  def foo &block
    lambda(&block)
  end
  
  it = foo{p 12}
  it.call #=> 12

@see [[c:Proc]],[[m:Proc.new]]

==== lambdaとProc.newの違い

lambda と Proc.new はどちらも Proc クラスのインスタンスを生成しますが、
生成されたプロックはいくつかの場面で挙動が異なります。 lambda の生成するプロック のほうが
よりメソッドに近い働きをするように設計されています。
proc は lambda の別名です。

: 引数の扱い

lambda のほうがより厳密です。引数の数が違っていると（メソッドのように）エラーになります。 Proc.new は引数を
多重代入に近い扱い方をします。

  Proc.new{|a,b,c| p a,b,c }.call([2,4])
  #=> 2
  #   4
  #   nil
  lambda{|a,b,c| p a,b,c }.call([2,4])
  # wrong number of arguments (1 for 3) (ArgumentError)

: スタックジャンプ時の挙動の違い

予約語を使ったジャンプで、ジャンプ先が異なるものがあります。
例えばプロック内部で return を行った場合、lambda はプロック自身を抜けますが、 Proc,new はプロックを
囲むメソッドを抜けます。

 def foo
   f = Proc.new { return "return from foo from inside proc" }
   f.call # control leaves foo here
   return "return from foo"
 end
 
 def bar
   f = lambda { return "return from lambda" }
   f.call # control does not leave bar here
   return "return from bar"
 end
 
 puts foo # prints "return from foo from inside proc"
 puts bar # prints "return from bar"

以下の表を参照してください。上例のように生成、実行を同一メソッド定義内で行った場合の結果です。

                return              next            break
  Proc.new  メソッドを抜ける  プロックを抜ける   使用不可（例外）
  lambda    プロックを抜ける  プロックを抜ける  プロックを抜ける
