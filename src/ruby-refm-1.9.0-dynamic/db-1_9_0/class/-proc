superclass=Object
type=class
library=_builtin
extended=
included=

ブロックをコンテキスト(ローカル変数のスコープやスタックフ
レーム)とともにオブジェクト化した手続きオブジェクトです。

Proc は
ローカル変数のスコープを導入しないことを除いて名前のない関数のように使
えます([[unknown:Ruby用語集/ダイナミックローカル変数]]は Proc ローカル
の変数として使えます)。

Proc がローカル変数のスコープを保持していることは以下の例で
変数 var を参照できていることからわかります。

  var = 1
  $foo = Proc.new { var }
  var = 2

  def foo
    $foo.call
  end

  p foo       # => 2

Proc を生成したメソッドからリターンしてしまった後は Proc
からの [[unknown:制御構造/return]], [[unknown:制御構造/retry]] は例外
[[c:LocalJumpError]] を発生させます。

  def foo
    proc { return }
  end

  foo.call
  # => in `call': return from proc-closure (LocalJumpError)

  def foo
    proc { retry }
  end

  foo.call
  # => in `call': retry from proc-closure (LocalJumpError)

ブロック付きメソッドに対して Proc オブジェクトを `&' を指定して渡すと
呼び出しブロックのように動作しますが、厳密には以下の違いがあります

  # 問題なし
  (1..5).each { break }

  # ruby 1.6.7, 1.8 で問題なし。1.6.8 では例外
  proc = Proc.new { break }
  (1..5).each(&proc)

  # ruby 1.6 では、LocalJumpError
  # ruby 1.8 では、each 再実行
  proc = Proc.new { retry }
  (1..5).each(&proc)
  #=> retry from proc-closure (LocalJumpError)

これは、Proc オブジェクトが呼び出しブロックとして振舞う際の制限です。
