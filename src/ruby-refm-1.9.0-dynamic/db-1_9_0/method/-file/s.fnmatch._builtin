visibility=public
kind=defined
names=fnmatch,fnmatch?

--- fnmatch(pattern, path, flags = 0)     -> bool 
--- fnmatch?(pattern, path, flags = 0)    -> bool

ファイル名のパターンマッチ [[man:fnmatch(3)]] を行います。
path が pattern にマッチすれば真を返します。そうでない場合には false を返します。

@param pattern パターンを文字列で指定します。ワイルドカードとして `*', `?', `[]' が使用できま
す。[[m:Dir.glob]] とは違って `{}' や `**/' は使用できません。

    %w(foo foobar bar).each {|f|
      p File.fnmatch("foo*", f)
    }
    # => true
         true
         false

@param path パスを表す文字列を指定します。

@param flags 以下の [[c:File::Constants]] で定義されている定数を論理和で指定することで、パターンマッチの動作を変更することができます。flags のデフォルト値は0(フラグ指定なし)です。

: FNM_NOESCAPE
 エスケープ文字 `\' を普通の文字とみなします。
//emlist{
  # デフォルトでは \ を伴う任意の文字はその文字にマッチしますが、
  # このフラグをつけると、\ が普通の文字として扱われます。
  p File.fnmatch('\a', 'a')                       # => true
  p File.fnmatch('\a', '\a', File::FNM_NOESCAPE)  # => true

  # 前者で * は、エスケープされているので "*" そのものにマッチ
  # します。
  p File.fnmatch('\*', 'a')                       # => false
  p File.fnmatch('\*', '\a', File::FNM_NOESCAPE)  # => true

  # 単体の \ は、このフラグの有無に関わらず \ にマッチします。
  # (シングルクォート文字列中では \\ は、\ であることに注意)
  p File.fnmatch('\\', '\\')                      # => true
  p File.fnmatch('\\', '\\', File::FNM_NOESCAPE)  # => true
//}
: FNM_PATHNAME
 ワイルドカード `*', `?', `[]' が `/' にマッチしなくなります。
 シェルのパターンマッチにはこのフラグが使用されています。
//emlist{
  p File.fnmatch('*', '/', File::FNM_PATHNAME)   # => false
  p File.fnmatch('?', '/', File::FNM_PATHNAME)   # => false
  p File.fnmatch('[/]', '/', File::FNM_PATHNAME) # => false
//}
: FNM_CASEFOLD
 アルファベットの大小文字を区別せずにパターンマッチを行います。
//emlist{
  p File.fnmatch('A', 'a', File::FNM_CASEFOLD)   # => true
//}
: FNM_DOTMATCH
 ワイルドカード `*', `?', `[]' が先頭の `.' にマッチするようになります。
//emlist{
  p File.fnmatch('*', '.', File::FNM_DOTMATCH)           # => true
  p File.fnmatch('?', '.', File::FNM_DOTMATCH)           # => true
  p File.fnmatch('[.]', '.', File::FNM_DOTMATCH)         # => true
  p File.fnmatch('foo/*', 'foo/.', File::FNM_DOTMATCH)   # => true
//}

