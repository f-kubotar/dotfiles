visibility=public
kind=defined
names=sub!

--- sub!(pattern, replace) -> ()

文字列中で pattern にマッチした最初の部分を文字列 replace へ破壊的に置き換えます。

Ruby 1.6 以前では pattern が文字列の場合、
その文字列を正規表現にコンパイルしていました。
しかし Ruby 1.8 以降では、その文字列そのものがパターンになります。

置換文字列 replace 中の \& と \0 はマッチした部分文字列に、
\1 ... \9 は n 番目の括弧の内容に置き換えられます。
置換文字列内では \`、\'、\+ も使えます。
これらは [[m:$`]]、[[m:$']]、[[m:$+]] に対応します。

sub! は通常 self を変更して返しますが、
置換が起こらなかった場合は nil を返します。

@arg pattern    置き換える文字列のパターン
@arg replace    pattern で指定した文字列と置き換える文字列

例:

    buf = "String-String"
    buf.sub!(/in./, "!!")
    p buf   # => "Str!!-String"

    buf = "String.String"
    buf.sub!(/in./, '<<\&>>')
    p buf   # => "Str<<ing>>-String"

注意:

引数 replace の中で [[m:$1]] を使うことはできません。
replace は sub メソッドの呼び出しより先に評価されるので、
まだ sub の正規表現マッチが行われておらず、
$1 がセットされていないからです。

また、sub では「\」が部分文字列との置き換えという特別な意味を持つため、
replace に「\」自身を入れたいときは
「\」を二重にエスケープしなければなりません。

例:
    # ひとつめの括弧にマッチした部分に置き換えるときによくやる間違い
    'abbbcd'.sub!(/a(b+)/, "#{$1}")       # NG
    'abbbcd'.sub!(/a(b+)/, "\1")          # NG
    'abbbcd'.sub!(/a(b+)/, "\\1")         # OK
    'abbbcd'.sub!(/a(b+)/, '\\1')         # OK
    'abbbcd'.sub!(/a(b+)/, '\1')          # OK
    'abbbcd'.sub!(/a(b+)/) { $1 }         # OK   これがもっとも安全

@see [[m:String#gsub]]

--- sub!(pattern) {|matched| .... } -> ()

文字列中で pattern にマッチした最初の部分をブロックに渡し、
その評価結果へ破壊的に置き換えます。

Ruby 1.6 以前では pattern が文字列の場合、
その文字列を正規表現にコンパイルしていました。
しかし Ruby 1.8 以降では、その文字列そのものがパターンになります。

また、ブロックなしの sub と違い、ブロックの中からは
組み込み変数 [[m:$1]], $2, $3, ... を問題なく参照できます。

@arg pattern    置き換える文字列のパターン

例:
    str = 'abcabc'
    str.sub!(/b/) {|s| s.upcase }
    p str    #=> "aBcabc"

    str = 'abcabc'
    str.sub!(/b/) { $&.upcase }
    p str    #=> "aBcabc"

@see [[m:String#gsub]]

